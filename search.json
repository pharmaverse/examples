[
  {
    "objectID": "sdtm/examples.html",
    "href": "sdtm/examples.html",
    "title": "SDTM Examples",
    "section": "",
    "text": "For SDTM mapping, there is currently an industry collaboration supported by CDISC for the {roak} R package. Read more here.\nOnce this completes and the package is made available as open source, we will be able to add examples showcasing how best to use this alongside other pharmaverse packages in this space - such as {datacutr} and {sdtmchecks}."
  },
  {
    "objectID": "tlg/index.html",
    "href": "tlg/index.html",
    "title": "TLG",
    "section": "",
    "text": "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus porttitor nulla ac libero varius pellentesque. Mauris at nisi a sapien commodo aliquet. Nulla sit amet magna vitae ante vestibulum semper. Integer hendrerit sem diam, et suscipit enim rhoncus vel. Mauris id feugiat est. Duis condimentum sagittis mattis. Donec vel varius elit. Fusce tristique et risus quis fermentum. Maecenas cursus congue tristique. Phasellus odio sapien, placerat vitae mattis nec, sagittis in libero. Praesent vitae congue est. Morbi a odio non ex gravida commodo sed eleifend nibh.\nCurabitur vitae nibh sit amet turpis viverra consequat. Sed egestas urna ac magna rhoncus viverra. Pellentesque id consequat purus. Ut ullamcorper, elit at pretium pellentesque, neque elit blandit diam, ut vehicula lectus enim fringilla dolor. Ut eget ante dui. Mauris vel dignissim nunc. Integer eget vehicula tellus. Etiam dignissim bibendum massa nec porta. Phasellus vehicula id lorem vitae commodo.\nMaecenas iaculis eros ut velit egestas sodales. Curabitur dapibus felis nulla, vel lobortis ante rutrum lacinia. Nam turpis arcu, scelerisque faucibus luctus eget, pellentesque ut nisl. Donec mollis justo vitae tincidunt consectetur. Donec malesuada non tortor eget ullamcorper. Mauris pulvinar imperdiet dolor ac elementum. Vestibulum malesuada in est non pulvinar."
  },
  {
    "objectID": "tlg/test.html",
    "href": "tlg/test.html",
    "title": "test",
    "section": "",
    "text": "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus porttitor nulla ac libero varius pellentesque. Mauris at nisi a sapien commodo aliquet. Nulla sit amet magna vitae ante vestibulum semper. Integer hendrerit sem diam, et suscipit enim rhoncus vel. Mauris id feugiat est. Duis condimentum sagittis mattis. Donec vel varius elit. Fusce tristique et risus quis fermentum. Maecenas cursus congue tristique. Phasellus odio sapien, placerat vitae mattis nec, sagittis in libero. Praesent vitae congue est. Morbi a odio non ex gravida commodo sed eleifend nibh.\nCurabitur vitae nibh sit amet turpis viverra consequat. Sed egestas urna ac magna rhoncus viverra. Pellentesque id consequat purus. Ut ullamcorper, elit at pretium pellentesque, neque elit blandit diam, ut vehicula lectus enim fringilla dolor. Ut eget ante dui. Mauris vel dignissim nunc. Integer eget vehicula tellus. Etiam dignissim bibendum massa nec porta. Phasellus vehicula id lorem vitae commodo.\nMaecenas iaculis eros ut velit egestas sodales. Curabitur dapibus felis nulla, vel lobortis ante rutrum lacinia. Nam turpis arcu, scelerisque faucibus luctus eget, pellentesque ut nisl. Donec mollis justo vitae tincidunt consectetur. Donec malesuada non tortor eget ullamcorper. Mauris pulvinar imperdiet dolor ac elementum. Vestibulum malesuada in est non pulvinar."
  },
  {
    "objectID": "session.html",
    "href": "session.html",
    "title": "Session Info",
    "section": "",
    "text": "sessionInfo()\n\nR version 4.2.2 Patched (2022-11-10 r83330)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.6 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0\nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       \n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nloaded via a namespace (and not attached):\n [1] htmlwidgets_1.6.2 compiler_4.2.2    fastmap_1.1.1     cli_3.6.1        \n [5] tools_4.2.2       htmltools_0.5.5   rstudioapi_0.14   yaml_2.3.7       \n [9] rmarkdown_2.25    knitr_1.44        xfun_0.40         digest_0.6.33    \n[13] jsonlite_1.8.7    rlang_1.1.1       evaluate_0.21"
  },
  {
    "objectID": "adam/adpc.html",
    "href": "adam/adpc.html",
    "title": "ADPC",
    "section": "",
    "text": "The Non-compartmental analysis (NCA) ADaM uses the CDISC Implementation Guide (https://www.cdisc.org/standards/foundational/adam/adamig-non-compartmental-analysis-input-data-v1-0). This example presented uses underlying EX and PC domains where the EX and PC domains represent data as collected and the ADPC ADaM is output. For more details see the admiral vignette."
  },
  {
    "objectID": "adam/adpc.html#first-load-packages",
    "href": "adam/adpc.html#first-load-packages",
    "title": "ADPC",
    "section": "First Load Packages",
    "text": "First Load Packages\nFirst we will load the packages required for our project. We will use admiral for the creation of analysis data. admiral requires dplyr, lubridate and stringr. We will use metacore and metatools to store and manipulate metadata from our specifications. We will use xportr to perform checks on the final data and export to a transport file.\nThe source SDTM data will come from the CDISC pilot study data stored in pharmaversesdtm.\n\n# Load Packages\nlibrary(admiral)\nlibrary(dplyr)\nlibrary(lubridate)\nlibrary(stringr)\nlibrary(metacore)\nlibrary(metatools)\nlibrary(xportr)\nlibrary(pharmaversesdtm)"
  },
  {
    "objectID": "adam/adpc.html#next-load-specifications-for-metacore",
    "href": "adam/adpc.html#next-load-specifications-for-metacore",
    "title": "ADPC",
    "section": "Next Load Specifications for Metacore",
    "text": "Next Load Specifications for Metacore\nWe have saved our specifications in an Excel file and will load them into metacore with the spec_to_metacore() function. The spec file can be found here.\n\n# ---- Load Specs for Metacore ----\n\nmetacore <- spec_to_metacore(\"pk_spec.xlsx\") %>%\n  select_dataset(\"ADPC\")"
  },
  {
    "objectID": "adam/adpc.html#load-source-datasets",
    "href": "adam/adpc.html#load-source-datasets",
    "title": "ADPC",
    "section": "Load Source Datasets",
    "text": "Load Source Datasets\nWe will load are SDTM data from pharmaversesdtm. The main components of this will be exposure data from EX and pharmacokinetic concentration data from PC. We will use ADSL for baseline characteristics and we will derive additional baselines from vital signs VS.\n\n# ---- Load source datasets ----\n# Load PC, EX, VS, LB and ADSL\ndata(\"pc\")\ndata(\"ex\")\ndata(\"vs\")\n\ndata(\"admiral_adsl\")\n\nadsl <- admiral_adsl\nex <- convert_blanks_to_na(ex)\npc <- convert_blanks_to_na(pc)\nvs <- convert_blanks_to_na(vs)"
  },
  {
    "objectID": "adam/adpc.html#derivations",
    "href": "adam/adpc.html#derivations",
    "title": "ADPC",
    "section": "Derivations",
    "text": "Derivations\nDerive PC Dates\nHere we use admiral functions for working with dates and we will also create a nominal time from first dose NFRLT for PC data based on PCTPTNUM.\n\n# Get list of ADSL vars required for derivations\nadsl_vars <- exprs(TRTSDT, TRTSDTM, TRT01P, TRT01A)\n\npc_dates <- pc %>%\n  # Join ADSL with PC (need TRTSDT for ADY derivation)\n  derive_vars_merged(\n    dataset_add = adsl,\n    new_vars = adsl_vars,\n    by_vars = exprs(STUDYID, USUBJID)\n  ) %>%\n  # Derive analysis date/time\n  # Impute missing time to 00:00:00\n  derive_vars_dtm(\n    new_vars_prefix = \"A\",\n    dtc = PCDTC,\n    time_imputation = \"00:00:00\"\n  ) %>%\n  # Derive dates and times from date/times\n  derive_vars_dtm_to_dt(exprs(ADTM)) %>%\n  derive_vars_dtm_to_tm(exprs(ADTM)) %>%\n  derive_vars_dy(reference_date = TRTSDT, source_vars = exprs(ADT)) %>%\n  # Derive event ID and nominal relative time from first dose (NFRLT)\n  mutate(\n    EVID = 0,\n    DRUG = PCTEST,\n    NFRLT = if_else(PCTPTNUM < 0, 0, PCTPTNUM), .after = USUBJID\n  )\n\nGet Dosing Information\nHere we also create nomimal time from first dose NFRLT for EX data based on VISITDY.\n\nex_dates <- ex %>%\n  derive_vars_merged(\n    dataset_add = adsl,\n    new_vars = adsl_vars,\n    by_vars = exprs(STUDYID, USUBJID)\n  ) %>%\n  # Keep records with nonzero dose\n  filter(EXDOSE > 0) %>%\n  # Add time and set missing end date to start date\n  # Impute missing time to 00:00:00\n  # Note all times are missing for dosing records in this example data\n  # Derive Analysis Start and End Dates\n  derive_vars_dtm(\n    new_vars_prefix = \"AST\",\n    dtc = EXSTDTC,\n    time_imputation = \"00:00:00\"\n  ) %>%\n  derive_vars_dtm(\n    new_vars_prefix = \"AEN\",\n    dtc = EXENDTC,\n    time_imputation = \"00:00:00\"\n  ) %>%\n  # Derive event ID and nominal relative time from first dose (NFRLT)\n  mutate(\n    EVID = 1,\n    NFRLT = 24 * (VISITDY - 1), .after = USUBJID\n  ) %>%\n  # Set missing end dates to start date\n  mutate(AENDTM = case_when(\n    is.na(AENDTM) ~ ASTDTM,\n    TRUE ~ AENDTM\n  )) %>%\n  # Derive dates from date/times\n  derive_vars_dtm_to_dt(exprs(ASTDTM)) %>%\n  derive_vars_dtm_to_dt(exprs(AENDTM))\n\nExpand Dosing Records\nSince there is a start date and end date for dosing records we need to expand the dosing records between the start date and end date using the admiral function create_single_dose_dataset().\n\nex_exp <- ex_dates %>%\n  create_single_dose_dataset(\n    dose_freq = EXDOSFRQ,\n    start_date = ASTDT,\n    start_datetime = ASTDTM,\n    end_date = AENDT,\n    end_datetime = AENDTM,\n    nominal_time = NFRLT,\n    lookup_table = dose_freq_lookup,\n    lookup_column = CDISC_VALUE,\n    keep_source_vars = exprs(\n      STUDYID, USUBJID, EVID, EXDOSFRQ, EXDOSFRM,\n      NFRLT, EXDOSE, EXDOSU, EXTRT, ASTDT, ASTDTM, AENDT, AENDTM,\n      VISIT, VISITNUM, VISITDY,\n      TRT01A, TRT01P, DOMAIN, EXSEQ, !!!adsl_vars\n    )\n  ) %>%\n  # Derive AVISIT based on nominal relative time\n  # Derive AVISITN to nominal time in whole days using integer division\n  # Define AVISIT based on nominal day\n  mutate(\n    AVISITN = NFRLT %/% 24 + 1,\n    AVISIT = paste(\"Day\", AVISITN),\n    ADTM = ASTDTM,\n    DRUG = EXTRT\n  ) %>%\n  # Derive dates and times from datetimes\n  derive_vars_dtm_to_dt(exprs(ADTM)) %>%\n  derive_vars_dtm_to_tm(exprs(ADTM)) %>%\n  derive_vars_dtm_to_tm(exprs(ASTDTM)) %>%\n  derive_vars_dtm_to_tm(exprs(AENDTM)) %>%\n  derive_vars_dy(reference_date = TRTSDT, source_vars = exprs(ADT))\n\nFind First Dose\nIn this section we will find the first dose for each subject and drug.\n\nadpc_first_dose <- pc_dates %>%\n  derive_vars_merged(\n    dataset_add = ex_exp,\n    filter_add = (EXDOSE > 0 & !is.na(ADTM)),\n    new_vars = exprs(FANLDTM = ADTM),\n    order = exprs(ADTM, EXSEQ),\n    mode = \"first\",\n    by_vars = exprs(STUDYID, USUBJID, DRUG)\n  ) %>%\n  filter(!is.na(FANLDTM)) %>%\n  # Derive AVISIT based on nominal relative time\n  # Derive AVISITN to nominal time in whole days using integer division\n  # Define AVISIT based on nominal day\n  mutate(\n    AVISITN = NFRLT %/% 24 + 1,\n    AVISIT = paste(\"Day\", AVISITN),\n  )\n\nFind Previous Dose and Next Dose\nUse derive_vars_joined() to find the previous dose and the next dose.\n\nadpc_prev <- adpc_first_dose %>%\n  derive_vars_joined(\n    dataset_add = ex_exp,\n    by_vars = exprs(USUBJID),\n    order = exprs(ADTM),\n    new_vars = exprs(\n      ADTM_prev = ADTM, EXDOSE_prev = EXDOSE, AVISIT_prev = AVISIT,\n      AENDTM_prev = AENDTM\n    ),\n    join_vars = exprs(ADTM),\n    filter_add = NULL,\n    filter_join = ADTM > ADTM.join,\n    mode = \"last\",\n    check_type = \"none\"\n  )\n\nadpc_next <- adpc_prev %>%\n  derive_vars_joined(\n    dataset_add = ex_exp,\n    by_vars = exprs(USUBJID),\n    order = exprs(ADTM),\n    new_vars = exprs(\n      ADTM_next = ADTM, EXDOSE_next = EXDOSE, AVISIT_next = AVISIT,\n      AENDTM_next = AENDTM\n    ),\n    join_vars = exprs(ADTM),\n    filter_add = NULL,\n    filter_join = ADTM <= ADTM.join,\n    mode = \"first\",\n    check_type = \"none\"\n  )\n\nFind Previous and Next Nominal Dose\nUse the same method to find the previous and next nominal times.\n\nadpc_nom_prev <- adpc_next %>%\n  derive_vars_joined(\n    dataset_add = ex_exp,\n    by_vars = exprs(USUBJID),\n    order = exprs(NFRLT),\n    new_vars = exprs(NFRLT_prev = NFRLT),\n    join_vars = exprs(NFRLT),\n    filter_add = NULL,\n    filter_join = NFRLT > NFRLT.join,\n    mode = \"last\",\n    check_type = \"none\"\n  )\n\nadpc_nom_next <- adpc_nom_prev %>%\n  derive_vars_joined(\n    dataset_add = ex_exp,\n    by_vars = exprs(USUBJID),\n    order = exprs(NFRLT),\n    new_vars = exprs(NFRLT_next = NFRLT),\n    join_vars = exprs(NFRLT),\n    filter_add = NULL,\n    filter_join = NFRLT <= NFRLT.join,\n    mode = \"first\",\n    check_type = \"none\"\n  )\n\nCombine PC and EX Data\nCombine PC and EX records and derive the additional relative time variables.\n\nadpc_arrlt <- bind_rows(adpc_nom_next, ex_exp) %>%\n  group_by(USUBJID, DRUG) %>%\n  mutate(\n    FANLDTM = min(FANLDTM, na.rm = TRUE),\n    min_NFRLT = min(NFRLT_prev, na.rm = TRUE),\n    maxdate = max(ADT[EVID == 0], na.rm = TRUE), .after = USUBJID\n  ) %>%\n  arrange(USUBJID, ADTM) %>%\n  ungroup() %>%\n  filter(ADT <= maxdate) %>%\n  # Derive Actual Relative Time from First Dose (AFRLT)\n  derive_vars_duration(\n    new_var = AFRLT,\n    start_date = FANLDTM,\n    end_date = ADTM,\n    out_unit = \"hours\",\n    floor_in = FALSE,\n    add_one = FALSE\n  ) %>%\n  # Derive Actual Relative Time from Reference Dose (ARRLT)\n  derive_vars_duration(\n    new_var = ARRLT,\n    start_date = ADTM_prev,\n    end_date = ADTM,\n    out_unit = \"hours\",\n    floor_in = FALSE,\n    add_one = FALSE\n  ) %>%\n  # Derive Actual Relative Time from Next Dose (AXRLT not kept)\n  derive_vars_duration(\n    new_var = AXRLT,\n    start_date = ADTM_next,\n    end_date = ADTM,\n    out_unit = \"hours\",\n    floor_in = FALSE,\n    add_one = FALSE\n  ) %>%\n  mutate(\n    ARRLT = case_when(\n      EVID == 1 ~ 0,\n      is.na(ARRLT) ~ AXRLT,\n      TRUE ~ ARRLT\n    ),\n    # Derive Reference Dose Date\n    PCRFTDTM = case_when(\n      EVID == 1 ~ ADTM,\n      is.na(ADTM_prev) ~ ADTM_next,\n      TRUE ~ ADTM_prev\n    )\n  ) %>%\n  # Derive dates and times from datetimes\n  derive_vars_dtm_to_dt(exprs(FANLDTM)) %>%\n  derive_vars_dtm_to_tm(exprs(FANLDTM)) %>%\n  derive_vars_dtm_to_dt(exprs(PCRFTDTM)) %>%\n  derive_vars_dtm_to_tm(exprs(PCRFTDTM))\n\nDerive Nominal Reference\nFor nominal relative times we calculate the nominal relative time to reference dose NRRLT.\n\n# Derive Nominal Relative Time from Reference Dose (NRRLT)\n\nadpc_nrrlt <- adpc_arrlt %>%\n  mutate(\n    NRRLT = case_when(\n      EVID == 1 ~ 0,\n      is.na(NFRLT_prev) ~ NFRLT - min_NFRLT,\n      TRUE ~ NFRLT - NFRLT_prev\n    ),\n    NXRLT = case_when(\n      EVID == 1 ~ 0,\n      TRUE ~ NFRLT - NFRLT_next\n    )\n  )\n\nDerive Analysis Variables\nHere we derive the analysis variables such as AVAL and ATPTREF.\n\nadpc_aval <- adpc_nrrlt %>%\n  mutate(\n    ATPTN = case_when(\n      EVID == 1 ~ 0,\n      TRUE ~ PCTPTNUM\n    ),\n    ATPT = case_when(\n      EVID == 1 ~ \"Dose\",\n      TRUE ~ PCTPT\n    ),\n    ATPTREF = case_when(\n      EVID == 1 ~ AVISIT,\n      is.na(AVISIT_prev) ~ AVISIT_next,\n      TRUE ~ AVISIT_prev\n    ),\n    # Derive baseline flag for pre-dose records\n    ABLFL = case_when(\n      ATPT == \"Pre-dose\" ~ \"Y\",\n      TRUE ~ NA_character_\n    ),\n    # Derive BASETYPE\n    BASETYPE = paste(ATPTREF, \"Baseline\"),\n\n    # Derive Actual Dose\n    DOSEA = case_when(\n      EVID == 1 ~ EXDOSE,\n      is.na(EXDOSE_prev) ~ EXDOSE_next,\n      TRUE ~ EXDOSE_prev\n    ),\n    # Derive Planned Dose\n    DOSEP = case_when(\n      TRT01P == \"Xanomeline High Dose\" ~ 81,\n      TRT01P == \"Xanomeline Low Dose\" ~ 54\n    ),\n    DOSEU = \"mg\",\n  ) %>%\n  # Derive relative time units\n  mutate(\n    FRLTU = \"h\",\n    RRLTU = \"h\",\n    # Derive PARAMCD\n    PARAMCD = coalesce(PCTESTCD, \"DOSE\"),\n    ALLOQ = PCLLOQ,\n    # Derive AVAL\n    AVAL = case_when(\n      EVID == 1 ~ EXDOSE,\n      PCSTRESC == \"<BLQ\" & NFRLT == 0 ~ 0,\n      PCSTRESC == \"<BLQ\" & NFRLT > 0 ~ 0.5 * ALLOQ,\n      TRUE ~ PCSTRESN\n    ),\n    AVALU = case_when(\n      EVID == 1 ~ EXDOSU,\n      TRUE ~ PCSTRESU\n    ),\n    AVALCAT1 = if_else(PCSTRESC == \"<BLQ\", PCSTRESC, prettyNum(signif(AVAL, digits = 3))),\n  ) %>%\n  # Add SRCSEQ\n  mutate(\n    SRCDOM = DOMAIN,\n    SRCVAR = \"SEQ\",\n    SRCSEQ = coalesce(PCSEQ, EXSEQ)\n  )\n\nDerive DTYPE Copy Records\nThe CDISC ADaM Implementation Guide for Non-compartmental Analysis uses duplicated records for analysis when a record needs to be used in more than one way. In this example the 24 hour post-dose record will also be used a the pre-dose record for the “Day 2” dose.\n\ndtype <- adpc_aval %>%\n  filter(NFRLT > 0 & NXRLT == 0 & EVID == 0 & !is.na(AVISIT_next)) %>%\n  select(-PCRFTDT, -PCRFTTM) %>%\n  # Re-derive variables in for DTYPE copy records\n  mutate(\n    ABLFL = NA_character_,\n    ATPTREF = AVISIT_next,\n    ARRLT = AXRLT,\n    NRRLT = NXRLT,\n    PCRFTDTM = ADTM_next,\n    DOSEA = EXDOSE_next,\n    BASETYPE = paste(AVISIT_next, \"Baseline\"),\n    ATPT = \"Pre-dose\",\n    ATPTN = NFRLT,\n    ABLFL = \"Y\",\n    DTYPE = \"COPY\"\n  ) %>%\n  derive_vars_dtm_to_dt(exprs(PCRFTDTM)) %>%\n  derive_vars_dtm_to_tm(exprs(PCRFTDTM))\n\nCombine Original and DTYPE Copy\nNow the duplicated records are combined with the original records.\n\nadpc_dtype <- bind_rows(adpc_aval, dtype) %>%\n  arrange(STUDYID, USUBJID, BASETYPE, ADTM, NFRLT) %>%\n  mutate(\n    # Derive MRRLT, ANL01FL and ANL02FL\n    MRRLT = if_else(ARRLT < 0, 0, ARRLT),\n    ANL01FL = \"Y\",\n    ANL02FL = if_else(is.na(DTYPE), \"Y\", NA_character_),\n  )\n\nDerive BASE and CHG\n\n# ---- Derive BASE and Calculate Change from Baseline ----\n\nadpc_base <- adpc_dtype %>%\n  derive_var_base(\n    by_vars = exprs(STUDYID, USUBJID, PARAMCD, BASETYPE),\n    source_var = AVAL,\n    new_var = BASE,\n    filter = ABLFL == \"Y\"\n  )\n\nadpc_chg <- derive_var_chg(adpc_base)\n\nDerive PARAM with {metatools}\n\nHere we derive PARAM and PARAMN using create_var_from_codelist() from metatools.\n\n# ---- Add ASEQ ----\n\nadpc_aseq <- adpc_chg %>%\n  # Calculate ASEQ\n  derive_var_obs_number(\n    new_var = ASEQ,\n    by_vars = exprs(STUDYID, USUBJID),\n    order = exprs(ADTM, BASETYPE, EVID, AVISITN, ATPTN, DTYPE),\n    check_type = \"error\"\n  ) %>%\n  # Derive PARAM and PARAMN using metatools\n  create_var_from_codelist(metacore, input_var = PARAMCD, out_var = PARAM) %>%\n  create_var_from_codelist(metacore, input_var = PARAMCD, out_var = PARAMN)\n\nDerive Additional Baselines\nHere we derive additional baseline values from VS for baseline height HTBL and weight WTBL and compute the body mass index (BMI) with compute_bmi().\n\n#---- Derive additional baselines from VS ----\n\nadpc_baselines <- adpc_aseq %>%\n  derive_vars_merged(\n    dataset_add = vs,\n    filter_add = VSTESTCD == \"HEIGHT\",\n    by_vars = exprs(STUDYID, USUBJID),\n    new_vars = exprs(HTBL = VSSTRESN, HTBLU = VSSTRESU)\n  ) %>%\n  derive_vars_merged(\n    dataset_add = vs,\n    filter_add = VSTESTCD == \"WEIGHT\" & VSBLFL == \"Y\",\n    by_vars = exprs(STUDYID, USUBJID),\n    new_vars = exprs(WTBL = VSSTRESN, WTBLU = VSSTRESU)\n  ) %>%\n  mutate(\n    BMIBL = compute_bmi(height = HTBL, weight = WTBL),\n    BMIBLU = \"kg/m^2\"\n  )\n\nCombine with ADSL\nIf needed, the other ADSL variables can now be added:\n\n# ---- Add all ADSL variables ----\n\n# Add all ADSL variables\nadpc_prefinal <- adpc_baselines %>%\n  derive_vars_merged(\n    dataset_add = select(adsl, !!!negate_vars(adsl_vars)),\n    by_vars = exprs(STUDYID, USUBJID)\n  )"
  },
  {
    "objectID": "adam/adpc.html#check-data-with-metacore",
    "href": "adam/adpc.html#check-data-with-metacore",
    "title": "ADPC",
    "section": "Check Data With Metacore",
    "text": "Check Data With Metacore\nWe use metacore to perform a number of checks on the data. We will drop variables not in the specs and make sure all the variables from the specs are included.\n\n# Apply metadata and perform associated checks ----\nadpc <- adpc_prefinal %>%\n  drop_unspec_vars(metacore) %>% # Drop unspecified variables from specs\n  check_variables(metacore) %>% # Check all variables specified are present and no more\n  check_ct_data(metacore) %>% # Checks all variables with CT only contain values within the CT\n  order_cols(metacore) %>% # Orders the columns according to the spec\n  sort_by_key(metacore) # Sorts the rows by the sort keys"
  },
  {
    "objectID": "adam/adpc.html#apply-labels-and-formats-with-xportr",
    "href": "adam/adpc.html#apply-labels-and-formats-with-xportr",
    "title": "ADPC",
    "section": "Apply Labels and Formats with xportr",
    "text": "Apply Labels and Formats with xportr\nUsing xportr we check variable type, assign variable lenght, add variable labels, add variable formats, and save a transport file.\n\nadpc_xpt <- adpc %>%\n  xportr_type(metacore) %>% # Coerce variable type to match spec\n  xportr_length(metacore) %>% # Assigns SAS length from a variable level metadata\n  xportr_label(metacore) %>% # Assigns variable label from metacore specifications\n  xportr_format(metacore) %>% # Assigns variable format from metacore specifications\n  xportr_df_label(metacore) %>% # Assigns dataset label from metacore specifications\n  xportr_write(\"adpc.xpt\") # Write xpt v5 transport file"
  },
  {
    "objectID": "adam/ADSL.html",
    "href": "adam/ADSL.html",
    "title": "ADSL",
    "section": "",
    "text": "This guide will show you how four pharmaverse packages, along with some from tidyverse, can be used to create an ADaM such as ADSL end-to-end, using pharmaversesdtm SDTM data as input.\nThe four packages used with a brief description of their purpose are as follows:\n\n\n{metacore}: provides harmonized metadata/specifications object.\n\n{metatools}: uses the provided metadata to build/enhance and check the dataset.\n\n{admiral}: provides the ADaM derivations.\n\n{xportr}: delivers the SAS transport file (XPT) and eSub checks.\n\nIt is important to understand metacore objects by reading through the above linked package site, as these are fundamental to being able to use metatools and xportr. Each company may need to build a specification reader to create these objects from their source standard specification templates."
  },
  {
    "objectID": "adam/ADSL.html#load-data-and-required-pharmaverse-packages",
    "href": "adam/ADSL.html#load-data-and-required-pharmaverse-packages",
    "title": "ADSL",
    "section": "Load Data and Required pharmaverse Packages",
    "text": "Load Data and Required pharmaverse Packages\nThe first step is to load our pharmaverse packages and input data. Below shows the versions of each of these package used.\n\nlibrary(metacore)\nlibrary(metatools)\nlibrary(pharmaversesdtm)\nlibrary(admiral)\nlibrary(xportr)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(lubridate)\nlibrary(stringr)\n\n# All our examples use the latest CRAN versions of packages each time the book is\n# deployed, but in case interested here are the versions\npackageVersion(\"metacore\")\npackageVersion(\"metatools\")\npackageVersion(\"admiral\")\npackageVersion(\"xportr\")\n\n# Read in input SDTM data \ndata(\"dm\")\ndata(\"ex\")\n\n[1] '0.1.2'\n[1] '0.1.5'\n[1] '0.12.3'\n[1] '0.3.1'\n\n\nNext we need to load the specification file in the form of a metacore object.\n\n# Read in metacore object \nload(metacore_example(\"pilot_ADaM.rda\"))\nmetacore <- metacore %>% \n   select_dataset(\"ADSL\")\n\nHere is an example of how a metacore object looks showing variable level metadata:\n\nmetacore$ds_vars\n\n# A tibble: 49 × 7\n   dataset variable key_seq order keep  core  supp_flag\n   <chr>   <chr>      <int> <int> <lgl> <chr> <lgl>    \n 1 ADSL    STUDYID       NA     1 FALSE <NA>  NA       \n 2 ADSL    USUBJID        1     2 FALSE <NA>  NA       \n 3 ADSL    SUBJID        NA     3 FALSE <NA>  NA       \n 4 ADSL    SITEID        NA     4 FALSE <NA>  NA       \n 5 ADSL    SITEGR1       NA     5 FALSE <NA>  NA       \n 6 ADSL    ARM           NA     6 FALSE <NA>  NA       \n 7 ADSL    TRT01P        NA     7 FALSE <NA>  NA       \n 8 ADSL    TRT01PN       NA     8 FALSE <NA>  NA       \n 9 ADSL    TRT01A        NA     9 FALSE <NA>  NA       \n10 ADSL    TRT01AN       NA    10 FALSE <NA>  NA       \n# ℹ 39 more rows"
  },
  {
    "objectID": "adam/ADSL.html#start-building-derivations",
    "href": "adam/ADSL.html#start-building-derivations",
    "title": "ADSL",
    "section": "Start Building Derivations",
    "text": "Start Building Derivations\nThe first derivation step we are going to do is to pull through all the columns that come directly from the SDTM datasets. You might know which datasets you are going to pull from directly already, but if you don’t you can call metatools::build_from_derived() with just an empty list and the error will tell you which datasets you need to supply.\n\nbuild_from_derived(metacore, list(), predecessor_only = FALSE)\n\nError in build_from_derived(metacore, list(), predecessor_only = FALSE): Not all datasets provided. Please pass the following dataset(s):\nDM\n\n\nIn this case all the columns come from DM so that is the only dataset we will pass into metatools::build_from_derived(). The resulting dataset has all the columns combined and any columns that needed renaming between SDTM and ADaM are renamed.\n\nadsl_preds <- build_from_derived(metacore, \n                                 ds_list = list(\"dm\" = dm), \n                                 predecessor_only = FALSE, keep = TRUE)\nhead(adsl_preds, n=10)\n\n# A tibble: 10 × 14\n   STUDYID      USUBJID SUBJID SITEID ARM     AGE AGEU  RACE  SEX   ETHNIC DTHFL\n   <chr>        <chr>   <chr>  <chr>  <chr> <dbl> <chr> <chr> <chr> <chr>  <chr>\n 1 CDISCPILOT01 01-701… 1015   701    Plac…    63 YEARS WHITE F     HISPA… <NA> \n 2 CDISCPILOT01 01-701… 1023   701    Plac…    64 YEARS WHITE M     HISPA… <NA> \n 3 CDISCPILOT01 01-701… 1028   701    Xano…    71 YEARS WHITE M     NOT H… <NA> \n 4 CDISCPILOT01 01-701… 1033   701    Xano…    74 YEARS WHITE M     NOT H… <NA> \n 5 CDISCPILOT01 01-701… 1034   701    Xano…    77 YEARS WHITE F     NOT H… <NA> \n 6 CDISCPILOT01 01-701… 1047   701    Plac…    85 YEARS WHITE F     NOT H… <NA> \n 7 CDISCPILOT01 01-701… 1057   701    Scre…    59 YEARS WHITE F     HISPA… <NA> \n 8 CDISCPILOT01 01-701… 1097   701    Xano…    68 YEARS WHITE M     NOT H… <NA> \n 9 CDISCPILOT01 01-701… 1111   701    Xano…    81 YEARS WHITE F     NOT H… <NA> \n10 CDISCPILOT01 01-701… 1115   701    Xano…    84 YEARS WHITE M     NOT H… <NA> \n# ℹ 3 more variables: RFSTDTC <chr>, RFENDTC <chr>, TRT01P <chr>\n\n\nNow we have the base dataset, we can start to create some variables. We can start with creating the subgroups using the controlled terminology, in this case AGEGR1. The metacore object holds all the metadata needed to make ADSL. Part of that metadata is the controlled terminology, which can help automate the creation of subgroups. We can look into the metacore object and see the controlled terminology for AGEGR1.\n\nget_control_term(metacore, variable = AGEGR1)\n\n# A tibble: 3 × 2\n  code  decode\n  <chr> <chr> \n1 <65   <65   \n2 65-80 65-80 \n3 >80   >80   \n\n\nBecause this controlled terminology is written in a fairly standard format we can automate the creation of AGEGR1. The function metatools::create_cat_var() takes in a metacore object, a reference variable - in this case AGE because that is the continuous variable AGEGR1 is created from, and the name of the sub-grouped variable. It will take the controlled terminology from the sub-grouped variable and group the reference variables accordingly.\nUsing a similar philosophy we can create the numeric version of RACE using the controlled terminology stored in the metacore object with the metatools::create_var_from_codelist() function.\n\nadsl_ct <- adsl_preds %>% \n   create_cat_var(metacore, ref_var = AGE, \n                  grp_var = AGEGR1, num_grp_var = AGEGR1N) %>% \n   create_var_from_codelist(metacore = metacore, \n                            input_var = RACE, \n                            out_var = RACEN) %>% \n   #Removing screen failures from ARM and TRT01P to match the define and FDA guidence\n   mutate(ARM = if_else(ARM == \"Screen Failure\", NA_character_, ARM),\n          TRT01P = if_else(TRT01P == \"Screen Failure\", NA_character_, TRT01P)\n   )\n\nhead(adsl_ct, n=10)\n\n# A tibble: 10 × 17\n   STUDYID      USUBJID SUBJID SITEID ARM     AGE AGEU  RACE  SEX   ETHNIC DTHFL\n   <chr>        <chr>   <chr>  <chr>  <chr> <dbl> <chr> <chr> <chr> <chr>  <chr>\n 1 CDISCPILOT01 01-701… 1015   701    Plac…    63 YEARS WHITE F     HISPA… <NA> \n 2 CDISCPILOT01 01-701… 1023   701    Plac…    64 YEARS WHITE M     HISPA… <NA> \n 3 CDISCPILOT01 01-701… 1028   701    Xano…    71 YEARS WHITE M     NOT H… <NA> \n 4 CDISCPILOT01 01-701… 1033   701    Xano…    74 YEARS WHITE M     NOT H… <NA> \n 5 CDISCPILOT01 01-701… 1034   701    Xano…    77 YEARS WHITE F     NOT H… <NA> \n 6 CDISCPILOT01 01-701… 1047   701    Plac…    85 YEARS WHITE F     NOT H… <NA> \n 7 CDISCPILOT01 01-701… 1057   701    <NA>     59 YEARS WHITE F     HISPA… <NA> \n 8 CDISCPILOT01 01-701… 1097   701    Xano…    68 YEARS WHITE M     NOT H… <NA> \n 9 CDISCPILOT01 01-701… 1111   701    Xano…    81 YEARS WHITE F     NOT H… <NA> \n10 CDISCPILOT01 01-701… 1115   701    Xano…    84 YEARS WHITE M     NOT H… <NA> \n# ℹ 6 more variables: RFSTDTC <chr>, RFENDTC <chr>, TRT01P <chr>, AGEGR1 <chr>,\n#   AGEGR1N <dbl>, RACEN <dbl>\n\n\nNow we have sorted out what we can easily do with controlled terminology it is time to start deriving some variables. Here you could refer directly to using the admiral template and vignette in practice, but for the purpose of this end-to-end ADaM vignette we will share a few exposure derivations from there. We derive the start and end of treatment (which requires dates to first be converted from DTC to DTM), the treatment duration, and the safety population flag.\n\nex_ext <- ex %>%\n  derive_vars_dtm(\n    dtc = EXSTDTC,\n    new_vars_prefix = \"EXST\"\n  ) %>%\n  derive_vars_dtm(\n    dtc = EXENDTC,\n    new_vars_prefix = \"EXEN\",\n    time_imputation = \"last\"\n  )\n\nadsl_raw <- adsl_ct %>%\n  derive_vars_merged(\n    dataset_add = ex_ext,\n    filter_add = (EXDOSE > 0 |\n      (EXDOSE == 0 &\n        str_detect(EXTRT, \"PLACEBO\"))) & nchar(EXSTDTC) >= 10,\n    new_vars = exprs(TRTSDTM = EXSTDTM),\n    order = exprs(EXSTDTM, EXSEQ),\n    mode = \"first\",\n    by_vars = exprs(STUDYID, USUBJID)\n  ) %>%\n  derive_vars_merged(\n    dataset_add = ex_ext,\n    filter_add = (EXDOSE > 0 |\n      (EXDOSE == 0 &\n        str_detect(EXTRT, \"PLACEBO\"))) & nchar(EXENDTC) >= 10,\n    new_vars = exprs(TRTEDTM = EXENDTM),\n    order = exprs(EXENDTM, EXSEQ),\n    mode = \"last\",\n    by_vars = exprs(STUDYID, USUBJID)\n  ) %>%\n   derive_vars_dtm_to_dt(source_vars = exprs(TRTSDTM, TRTEDTM)) %>%  #Convert Datetime variables to date \n   derive_var_trtdurd() %>% \n   derive_var_merged_exist_flag(\n     dataset_add = ex,\n     by_vars = exprs(STUDYID, USUBJID),\n     new_var = SAFFL,\n     condition = (EXDOSE > 0 | (EXDOSE == 0 & str_detect(EXTRT, \"PLACEBO\")))\n   ) %>% \n   drop_unspec_vars(metacore) #This will drop any columns that aren't specified in the metacore object\n\nThe following variable(s) were dropped:\n  TRTSDTM\n  TRTEDTM\n\nhead(adsl_raw, n=10)\n\n# A tibble: 10 × 21\n   STUDYID      USUBJID SUBJID SITEID ARM     AGE AGEU  RACE  SEX   ETHNIC DTHFL\n   <chr>        <chr>   <chr>  <chr>  <chr> <dbl> <chr> <chr> <chr> <chr>  <chr>\n 1 CDISCPILOT01 01-701… 1015   701    Plac…    63 YEARS WHITE F     HISPA… <NA> \n 2 CDISCPILOT01 01-701… 1023   701    Plac…    64 YEARS WHITE M     HISPA… <NA> \n 3 CDISCPILOT01 01-701… 1028   701    Xano…    71 YEARS WHITE M     NOT H… <NA> \n 4 CDISCPILOT01 01-701… 1033   701    Xano…    74 YEARS WHITE M     NOT H… <NA> \n 5 CDISCPILOT01 01-701… 1034   701    Xano…    77 YEARS WHITE F     NOT H… <NA> \n 6 CDISCPILOT01 01-701… 1047   701    Plac…    85 YEARS WHITE F     NOT H… <NA> \n 7 CDISCPILOT01 01-701… 1057   701    <NA>     59 YEARS WHITE F     HISPA… <NA> \n 8 CDISCPILOT01 01-701… 1097   701    Xano…    68 YEARS WHITE M     NOT H… <NA> \n 9 CDISCPILOT01 01-701… 1111   701    Xano…    81 YEARS WHITE F     NOT H… <NA> \n10 CDISCPILOT01 01-701… 1115   701    Xano…    84 YEARS WHITE M     NOT H… <NA> \n# ℹ 10 more variables: RFSTDTC <chr>, RFENDTC <chr>, TRT01P <chr>,\n#   AGEGR1 <chr>, AGEGR1N <dbl>, RACEN <dbl>, TRTSDT <date>, TRTEDT <date>,\n#   TRTDURD <dbl>, SAFFL <chr>"
  },
  {
    "objectID": "adam/ADSL.html#apply-metadata-to-create-an-esub-xpt-and-perform-associated-checks",
    "href": "adam/ADSL.html#apply-metadata-to-create-an-esub-xpt-and-perform-associated-checks",
    "title": "ADSL",
    "section": "Apply Metadata to Create an eSub XPT and Perform Associated Checks",
    "text": "Apply Metadata to Create an eSub XPT and Perform Associated Checks\nNow we have all the variables defined we can run some checks before applying the necessary formatting. The top four functions performing checks and sorting/ordering come from metatools, whereas the others focused around applying attributes to prepare for XPT come from xportr. At the end you could add a call to xportr::xportr_write() to produce the XPT file.\n\nadsl_raw %>% \n   check_variables(metacore) %>% # Check all variables specified are present and no more\n   check_ct_data(metacore, na_acceptable = TRUE) %>% # Checks all variables with CT only contain values within the CT\n   order_cols(metacore) %>% # Orders the columns according to the spec\n   sort_by_key(metacore) %>% # Sorts the rows by the sort keys \n   xportr_type(metacore) %>% # Coerce variable type to match spec\n   xportr_length(metacore) %>% # Assigns SAS length from a variable level metadata \n   xportr_label(metacore) %>% # Assigns variable label from metacore specifications \n   xportr_df_label(metacore) # Assigns dataset label from metacore specifications\n\n# A tibble: 306 × 49\n   STUDYID     USUBJID SUBJID SITEID SITEGR1 ARM   TRT01P TRT01PN TRT01A TRT01AN\n   <chr>       <chr>   <chr>  <chr>  <chr>   <chr> <chr>    <dbl> <chr>    <dbl>\n 1 CDISCPILOT… 01-701… 1015   701    <NA>    Plac… Place…      NA <NA>        NA\n 2 CDISCPILOT… 01-701… 1023   701    <NA>    Plac… Place…      NA <NA>        NA\n 3 CDISCPILOT… 01-701… 1028   701    <NA>    Xano… Xanom…      NA <NA>        NA\n 4 CDISCPILOT… 01-701… 1033   701    <NA>    Xano… Xanom…      NA <NA>        NA\n 5 CDISCPILOT… 01-701… 1034   701    <NA>    Xano… Xanom…      NA <NA>        NA\n 6 CDISCPILOT… 01-701… 1047   701    <NA>    Plac… Place…      NA <NA>        NA\n 7 CDISCPILOT… 01-701… 1057   701    <NA>    <NA>  <NA>        NA <NA>        NA\n 8 CDISCPILOT… 01-701… 1097   701    <NA>    Xano… Xanom…      NA <NA>        NA\n 9 CDISCPILOT… 01-701… 1111   701    <NA>    Xano… Xanom…      NA <NA>        NA\n10 CDISCPILOT… 01-701… 1115   701    <NA>    Xano… Xanom…      NA <NA>        NA\n# ℹ 296 more rows\n# ℹ 39 more variables: TRTSDT <date>, TRTEDT <date>, TRTDURD <dbl>,\n#   AVGDD <dbl>, CUMDOSE <dbl>, AGE <dbl>, AGEGR1 <chr>, AGEGR1N <dbl>,\n#   AGEU <chr>, RACE <chr>, RACEN <dbl>, SEX <chr>, ETHNIC <chr>, SAFFL <chr>,\n#   ITTFL <chr>, EFFFL <chr>, COMP8FL <chr>, COMP16FL <chr>, COMP24FL <chr>,\n#   DISCONFL <chr>, DSRAEFL <chr>, DTHFL <chr>, BMIBL <dbl>, BMIBLGR1 <chr>,\n#   HEIGHTBL <dbl>, WEIGHTBL <dbl>, EDUCLVL <dbl>, DISONSDT <lgl>, …"
  },
  {
    "objectID": "adam/adppk.html",
    "href": "adam/adppk.html",
    "title": "ADPPK",
    "section": "",
    "text": "The Population PK Analysis Data (ADPPK) follows the CDISC Implementation Guide (https://www.cdisc.org/standards/foundational/adam/basic-data-structure-adam-poppk-implementation-guide-v1-0). Population PK models generally make use of nonlinear mixed effects models that require numeric variables. The data used in the models will include both dosing and concentration records, relative time variables, and numeric covariate variables. A DV or dependent variable is often expected. This is equivalent to the ADaM AVAL variable and will be included in addition to AVAL for ADPPK."
  },
  {
    "objectID": "adam/adppk.html#first-load-packages",
    "href": "adam/adppk.html#first-load-packages",
    "title": "ADPPK",
    "section": "First Load Packages",
    "text": "First Load Packages\nFirst we will load the packages required for our project. We will use admiral for the creation of analysis data. admiral requires dplyr, lubridate and stringr. We will use metacore and metatools to store and manipulate metadata from our specifications. We will use xportr to perform checks on the final data and export to a transport file.\nThe source SDTM data will come from the CDISC pilot study data stored in pharmaversesdtm.\n\n# Load Packages\nlibrary(admiral)\nlibrary(dplyr)\nlibrary(lubridate)\nlibrary(stringr)\nlibrary(metacore)\nlibrary(metatools)\nlibrary(xportr)\nlibrary(readr)\nlibrary(pharmaversesdtm)"
  },
  {
    "objectID": "adam/adppk.html#next-load-specifications-for-metacore",
    "href": "adam/adppk.html#next-load-specifications-for-metacore",
    "title": "ADPPK",
    "section": "Next Load Specifications for Metacore",
    "text": "Next Load Specifications for Metacore\nWe have saved our specifications in an Excel file and will load them into metacore with the spec_to_metacore() function. The spec file can be found here\n\n# ---- Load Specs for Metacore ----\nmetacore <- spec_to_metacore(\"pk_spec.xlsx\") %>%\n  select_dataset(\"ADPPK\")"
  },
  {
    "objectID": "adam/adppk.html#load-source-datasets",
    "href": "adam/adppk.html#load-source-datasets",
    "title": "ADPPK",
    "section": "Load Source Datasets",
    "text": "Load Source Datasets\nWe will load are SDTM data from pharmaversesdtm. The main components of this will be exposure data from EX and pharmacokinetic concentration data from PC. We will use ADSL for baseline characteristics and we will derive additional baselines from vital signs VS and laboratory data LB.\n\n# ---- Load source datasets ----\n# Load PC, EX, VS, LB and ADSL\ndata(\"pc\")\ndata(\"ex\")\ndata(\"vs\")\ndata(\"lb\")\n\ndata(\"admiral_adsl\")\nadsl <- admiral_adsl\n\nex <- convert_blanks_to_na(ex)\npc <- convert_blanks_to_na(pc)\nvs <- convert_blanks_to_na(vs)\nlb <- convert_blanks_to_na(lb)"
  },
  {
    "objectID": "adam/adppk.html#derivations",
    "href": "adam/adppk.html#derivations",
    "title": "ADPPK",
    "section": "Derivations",
    "text": "Derivations\nDerive PC Dates\nAt this step, it may be useful to join ADSL to your PC and EX domains as well. Only the ADSL variables used for derivations are selected at this step. The rest of the relevant ADSL variables will be added later.\nIn this case we will keep TRTSDT/TRTSDTM for day derivation and TRT01P/TRT01A for planned and actual treatments.\nIn this segment we will use derive_vars_merged() to join the ADSL variables and the following admiral functions to derive analysis dates, times and days:\n\nderive_vars_dtm()\nderive_vars_dtm_to_dt()\nderive_vars_dtm_to_tm()\nderive_vars_dy()\n\nWe will also create NFRLT for PC data based on PCTPTNUM. We will create an event ID (EVID) of 0 for concentration records and 1 for dosing records.\n\n# ---- Derivations ----\n\n# Get list of ADSL vars required for derivations\nadsl_vars <- exprs(TRTSDT, TRTSDTM, TRT01P, TRT01A)\n\npc_dates <- pc %>%\n  # Join ADSL with PC (need TRTSDT for ADY derivation)\n  derive_vars_merged(\n    dataset_add = adsl,\n    new_vars = adsl_vars,\n    by_vars = exprs(STUDYID, USUBJID)\n  ) %>%\n  # Derive analysis date/time\n  # Impute missing time to 00:00:00\n  derive_vars_dtm(\n    new_vars_prefix = \"A\",\n    dtc = PCDTC,\n    time_imputation = \"00:00:00\"\n  ) %>%\n  # Derive dates and times from date/times\n  derive_vars_dtm_to_dt(exprs(ADTM)) %>%\n  derive_vars_dtm_to_tm(exprs(ADTM)) %>%\n  # Derive event ID and nominal relative time from first dose (NFRLT)\n  mutate(\n    EVID = 0,\n    DRUG = PCTEST,\n    NFRLT = if_else(PCTPTNUM < 0, 0, PCTPTNUM), .after = USUBJID\n  )\n\nGet Dosing Information\nNext we will also join ADSL data with EX and derive dates/times. This section uses the admiral functions derive_vars_merged(), derive_vars_dtm(), and derive_vars_dtm_to_dt(). Time is imputed to 00:00:00 here for reasons specific to the sample data. Other imputation times may be used based on study details. Here we create NFRLT for EX data based on VISITDY using the formula (VISITDY - 1) * 24 using dplyr::mutate.\n\n# ---- Get dosing information ----\n\nex_dates <- ex %>%\n  derive_vars_merged(\n    dataset_add = adsl,\n    new_vars = adsl_vars,\n    by_vars = exprs(STUDYID, USUBJID)\n  ) %>%\n  # Keep records with nonzero dose\n  filter(EXDOSE > 0) %>%\n  # Add time and set missing end date to start date\n  # Impute missing time to 00:00:00\n  # Note all times are missing for dosing records in this example data\n  # Derive Analysis Start and End Dates\n  derive_vars_dtm(\n    new_vars_prefix = \"AST\",\n    dtc = EXSTDTC,\n    time_imputation = \"00:00:00\"\n  ) %>%\n  derive_vars_dtm(\n    new_vars_prefix = \"AEN\",\n    dtc = EXENDTC,\n    time_imputation = \"00:00:00\"\n  ) %>%\n  # Derive event ID and nominal relative time from first dose (NFRLT)\n  mutate(\n    EVID = 1,\n    NFRLT = 24 * (VISITDY - 1), .after = USUBJID\n  ) %>%\n  # Set missing end dates to start date\n  mutate(AENDTM = case_when(\n    is.na(AENDTM) ~ ASTDTM,\n    TRUE ~ AENDTM\n  )) %>%\n  # Derive dates from date/times\n  derive_vars_dtm_to_dt(exprs(ASTDTM)) %>%\n  derive_vars_dtm_to_dt(exprs(AENDTM))\n\nExpand Dosing Records\nThe admiral function create_single_dose_dataset() will be used to expand dosing records between the start date and end date. The nominal time will also be expanded based on the values of EXDOSFRQ, for example “QD” will result in nominal time being incremented by 24 hours and “BID” will result in nominal time being incremented by 12 hours.\n\n# ---- Expand dosing records between start and end dates ----\n# Updated function includes nominal_time parameter\n\nex_exp <- ex_dates %>%\n  create_single_dose_dataset(\n    dose_freq = EXDOSFRQ,\n    start_date = ASTDT,\n    start_datetime = ASTDTM,\n    end_date = AENDT,\n    end_datetime = AENDTM,\n    nominal_time = NFRLT,\n    lookup_table = dose_freq_lookup,\n    lookup_column = CDISC_VALUE,\n    keep_source_vars = exprs(\n      STUDYID, USUBJID, EVID, EXDOSFRQ, EXDOSFRM,\n      NFRLT, EXDOSE, EXDOSU, EXTRT, ASTDT, ASTDTM, AENDT, AENDTM,\n      VISIT, VISITNUM, VISITDY,\n      TRT01A, TRT01P, DOMAIN, EXSEQ, !!!adsl_vars\n    )\n  ) %>%\n  # Derive AVISIT based on nominal relative time\n  # Derive AVISITN to nominal time in whole days using integer division\n  # Define AVISIT based on nominal day\n  mutate(\n    AVISITN = NFRLT %/% 24 + 1,\n    AVISIT = paste(\"Day\", AVISITN),\n    ADTM = ASTDTM,\n    DRUG = EXTRT\n  ) %>%\n  # Derive dates and times from datetimes\n  derive_vars_dtm_to_dt(exprs(ADTM)) %>%\n  derive_vars_dtm_to_tm(exprs(ADTM)) %>%\n  derive_vars_dtm_to_tm(exprs(ASTDTM)) %>%\n  derive_vars_dtm_to_tm(exprs(AENDTM))\n\nFind First Dose\nWe find the first dose for the concentration records using the admiral function derive_vars_merged()\n\n# ---- Find first dose per treatment per subject ----\n# ---- Join with ADPPK data and keep only subjects with dosing ----\n\nadppk_first_dose <- pc_dates %>%\n  derive_vars_merged(\n    dataset_add = ex_exp,\n    filter_add = (!is.na(ADTM)),\n    new_vars = exprs(FANLDTM = ADTM, EXDOSE_first = EXDOSE),\n    order = exprs(ADTM, EXSEQ),\n    mode = \"first\",\n    by_vars = exprs(STUDYID, USUBJID, DRUG)\n  ) %>%\n  filter(!is.na(FANLDTM)) %>%\n  # Derive AVISIT based on nominal relative time\n  # Derive AVISITN to nominal time in whole days using integer division\n  # Define AVISIT based on nominal day\n  mutate(\n    AVISITN = NFRLT %/% 24 + 1,\n    AVISIT = paste(\"Day\", AVISITN),\n  )\n\nFind Previous Dose\nFor ADPPK we will find the previous dose with respect to actual time and nominal time. We will use `derive_vars_joined().\n\n# ---- Find previous dose  ----\n\nadppk_prev <- adppk_first_dose %>%\n  derive_vars_joined(\n    dataset_add = ex_exp,\n    by_vars = exprs(USUBJID),\n    order = exprs(ADTM),\n    new_vars = exprs(\n      ADTM_prev = ADTM, EXDOSE_prev = EXDOSE, AVISIT_prev = AVISIT,\n      AENDTM_prev = AENDTM\n    ),\n    join_vars = exprs(ADTM),\n    filter_add = NULL,\n    filter_join = ADTM > ADTM.join,\n    mode = \"last\",\n    check_type = \"none\"\n  )\n\nFind Previous Nominal Dose\n\n# ---- Find previous nominal dose ----\n\nadppk_nom_prev <- adppk_prev %>%\n  derive_vars_joined(\n    dataset_add = ex_exp,\n    by_vars = exprs(USUBJID),\n    order = exprs(NFRLT),\n    new_vars = exprs(NFRLT_prev = NFRLT),\n    join_vars = exprs(NFRLT),\n    filter_add = NULL,\n    filter_join = NFRLT > NFRLT.join,\n    mode = \"last\",\n    check_type = \"none\"\n  )\n\nCombine PC and EX Data\nHere we combine PC and EX records. We will derive the relative time variables AFRLT (Actual Relative Time from First Dose), APRLT (Actual Relative Time from Previous Dose), and NPRLT (Nominal Relative Time from Previous Dose). Use derive_vars_duration() to derive AFRLT and APRLT. Note we defined EVID above with values of 0 for observation records and 1 for dosing records.\n\n# ---- Combine ADPPK and EX data ----\n# Derive Relative Time Variables\n\nadppk_aprlt <- bind_rows(adppk_nom_prev, ex_exp) %>%\n  group_by(USUBJID, DRUG) %>%\n  mutate(\n    FANLDTM = min(FANLDTM, na.rm = TRUE),\n    min_NFRLT = min(NFRLT, na.rm = TRUE),\n    maxdate = max(ADT[EVID == 0], na.rm = TRUE), .after = USUBJID\n  ) %>%\n  arrange(USUBJID, ADTM) %>%\n  ungroup() %>%\n  filter(ADT <= maxdate) %>%\n  # Derive Actual Relative Time from First Dose (AFRLT)\n  derive_vars_duration(\n    new_var = AFRLT,\n    start_date = FANLDTM,\n    end_date = ADTM,\n    out_unit = \"hours\",\n    floor_in = FALSE,\n    add_one = FALSE\n  ) %>%\n  # Derive Actual Relative Time from Reference Dose (APRLT)\n  derive_vars_duration(\n    new_var = APRLT,\n    start_date = ADTM_prev,\n    end_date = ADTM,\n    out_unit = \"hours\",\n    floor_in = FALSE,\n    add_one = FALSE\n  ) %>%\n  # Derive APRLT\n  mutate(\n    APRLT = case_when(\n      EVID == 1 ~ 0,\n      is.na(APRLT) ~ AFRLT,\n      TRUE ~ APRLT\n    ),\n    NPRLT = case_when(\n      EVID == 1 ~ 0,\n      is.na(NFRLT_prev) ~ NFRLT - min_NFRLT,\n      TRUE ~ NFRLT - NFRLT_prev\n    )\n  )\n\nDerive Analysis Variables\nThe expected analysis variable for ADPPK is DV or dependent variable. For this example DV is set to the numeric concentration value PCSTRESN. We will also include AVAL equivalent to DV for consistency with CDISC ADaM standards. MDV missing dependent variable will also be included.\n\n# ---- Derive Analysis Variables ----\n# Derive actual dose DOSEA and planned dose DOSEP,\n# Derive AVAL and DV\n\nadppk_aval <- adppk_aprlt %>%\n  mutate(\n    # Derive Actual Dose\n    DOSEA = case_when(\n      EVID == 1 ~ EXDOSE,\n      is.na(EXDOSE_prev) ~ EXDOSE_first,\n      TRUE ~ EXDOSE_prev\n    ),\n    # Derive Planned Dose\n    DOSEP = case_when(\n      TRT01P == \"Xanomeline High Dose\" ~ 81,\n      TRT01P == \"Xanomeline Low Dose\" ~ 54,\n      TRT01P == \"Placebo\" ~ 0\n    ),\n    # Derive PARAMCD\n    PARAMCD = case_when(\n      EVID == 1 ~ \"DOSE\",\n      TRUE ~ PCTESTCD\n    ),\n    ALLOQ = PCLLOQ,\n    # Derive CMT\n    CMT = case_when(\n      EVID == 1 ~ 1,\n      TRUE ~ 2\n    ),\n    # Derive BLQFL/BLQFN\n    BLQFL = case_when(\n      PCSTRESC == \"<BLQ\" ~ \"Y\",\n      TRUE ~ \"N\"\n    ),\n    BLQFN = case_when(\n      PCSTRESC == \"<BLQ\" ~ 1,\n      TRUE ~ 0\n    ),\n    AMT = case_when(\n      EVID == 1 ~ EXDOSE,\n      TRUE ~ NA_real_\n    ),\n    # Derive DV and AVAL\n    DV = PCSTRESN,\n    DVID = PCTESTCD,\n    AVAL = DV,\n    DVL = case_when(\n      DV != 0 ~ log(DV),\n      TRUE ~ NA_real_\n    ),\n    # Derive MDV\n    MDV = case_when(\n      EVID == 1 ~ 1,\n      is.na(DV) ~ 1,\n      TRUE ~ 0\n    ),\n    AVALU = case_when(\n      EVID == 1 ~ NA_character_,\n      TRUE ~ PCSTRESU\n    ),\n    RLTU = \"h\",\n    USTRESC = PCSTRESC,\n    UDTC = format_ISO8601(ADTM),\n    II = if_else(EVID == 1, 1, 0),\n    SS = if_else(EVID == 1, 1, 0),\n    ADDL = 0,\n    OCC = 1,\n  )\n\nAdd ASEQ\nWe add a sequence variable using the admiral function derive_var_obs_number().\n\n# ---- Add ASEQ ----\n\nadppk_aseq <- adppk_aval %>%\n  # Calculate ASEQ\n  derive_var_obs_number(\n    new_var = ASEQ,\n    by_vars = exprs(STUDYID, USUBJID),\n    order = exprs(AFRLT, EVID),\n    check_type = \"error\"\n  ) %>%\n  mutate(\n    PROJID = DRUG,\n    PROJIDN = 1,\n    PART = 1,\n  )"
  },
  {
    "objectID": "adam/adppk.html#derive-covariates-using-metacore",
    "href": "adam/adppk.html#derive-covariates-using-metacore",
    "title": "ADPPK",
    "section": "Derive Covariates Using Metacore",
    "text": "Derive Covariates Using Metacore\nIn this step we will create our numeric covariates using the create_var_from_codelist() function from metatools.\n\n#---- Derive Covariates ----\n# Include numeric values for STUDYIDN, USUBJIDN, SEXN, RACEN etc.\n\ncovar <- adsl %>%\n  create_var_from_codelist(metacore, input_var = STUDYID, out_var = STUDYIDN) %>%\n  create_var_from_codelist(metacore, input_var = SEX, out_var = SEXN) %>%\n  create_var_from_codelist(metacore, input_var = RACE, out_var = RACEN) %>%\n  create_var_from_codelist(metacore, input_var = ETHNIC, out_var = AETHNIC) %>%\n  create_var_from_codelist(metacore, input_var = AETHNIC, out_var = AETHNICN) %>%\n  create_var_from_codelist(metacore, input_var = ARMCD, out_var = COHORT) %>%\n  create_var_from_codelist(metacore, input_var = ARMCD, out_var = COHORTC) %>%\n  create_var_from_codelist(metacore, input_var = COUNTRY, out_var = COUNTRYN) %>%\n  create_var_from_codelist(metacore, input_var = COUNTRY, out_var = COUNTRYL) %>%\n  mutate(\n    STUDYIDN = as.numeric(word(USUBJID, 1, sep = fixed(\"-\"))),\n    SITEIDN = as.numeric(word(USUBJID, 2, sep = fixed(\"-\"))),\n    USUBJIDN = as.numeric(word(USUBJID, 3, sep = fixed(\"-\"))),\n    SUBJIDN = as.numeric(SUBJID),\n    ROUTE = unique(ex$EXROUTE),\n    FORM = unique(ex$EXDOSFRM),\n    REGION1 = COUNTRY,\n    REGION1N = COUNTRYN,\n    SUBJTYPC = \"Volunteer\",\n  ) %>%\n  create_var_from_codelist(metacore, input_var = FORM, out_var = FORMN) %>%\n  create_var_from_codelist(metacore, input_var = ROUTE, out_var = ROUTEN) %>%\n  create_var_from_codelist(metacore, input_var = SUBJTYPC, out_var = SUBJTYP)\n\nDerive Additional Baselines\nNext we add additional baselines from vital signs and laboratory data. We will use the admiral functions derive_vars_merged() and derive_vars_transposed() to add these.\n\n#---- Derive additional baselines from VS and LB ----\n\nlabsbl <- lb %>%\n  filter(LBBLFL == \"Y\" & LBTESTCD %in% c(\"CREAT\", \"ALT\", \"AST\", \"BILI\")) %>%\n  mutate(LBTESTCDB = paste0(LBTESTCD, \"BL\")) %>%\n  select(STUDYID, USUBJID, LBTESTCDB, LBSTRESN)\n\ncovar_vslb <- covar %>%\n  derive_vars_merged(\n    dataset_add = vs,\n    filter_add = VSTESTCD == \"HEIGHT\",\n    by_vars = exprs(STUDYID, USUBJID),\n    new_vars = exprs(HTBL = VSSTRESN)\n  ) %>%\n  derive_vars_merged(\n    dataset_add = vs,\n    filter_add = VSTESTCD == \"WEIGHT\" & VSBLFL == \"Y\",\n    by_vars = exprs(STUDYID, USUBJID),\n    new_vars = exprs(WTBL = VSSTRESN)\n  ) %>%\n  derive_vars_transposed(\n    dataset_merge = labsbl,\n    by_vars = exprs(STUDYID, USUBJID),\n    key_var = LBTESTCDB,\n    value_var = LBSTRESN\n  ) %>%\n  mutate(\n    BMIBL = compute_bmi(height = HTBL, weight = WTBL),\n    BSABL = compute_bsa(\n      height = HTBL,\n      weight = HTBL,\n      method = \"Mosteller\"\n    ),\n    CRCLBL = compute_egfr(\n      creat = CREATBL, creatu = \"SI\", age = AGE, weight = WTBL, sex = SEX,\n      method = \"CRCL\"\n    ),\n    EGFRBL = compute_egfr(\n      creat = CREATBL, creatu = \"SI\", age = AGE, weight = WTBL, sex = SEX,\n      method = \"CKD-EPI\"\n    )\n  ) %>%\n  rename(TBILBL = BILIBL)\n\nCombine with Covariates\nWe combine our covariates with the rest of the data\n\n# Combine covariates with APPPK data\n\nadppk_prefinal <- adppk_aseq %>%\n  derive_vars_merged(\n    dataset_add = select(covar_vslb, !!!negate_vars(adsl_vars)),\n    by_vars = exprs(STUDYID, USUBJID)\n  ) %>%\n  arrange(STUDYIDN, USUBJIDN, AFRLT, EVID) %>%\n  # Add RECSEQ\n  # Exclude records if needed\n  mutate(\n    RECSEQ = row_number(),\n    EXCLFCOM = \"None\"\n  ) %>%\n  create_var_from_codelist(metacore, input_var = DVID, out_var = DVIDN) %>%\n  create_var_from_codelist(metacore, input_var = EXCLFCOM, out_var = EXCLF)"
  },
  {
    "objectID": "adam/adppk.html#check-data-with-metacore",
    "href": "adam/adppk.html#check-data-with-metacore",
    "title": "ADPPK",
    "section": "Check Data With Metacore",
    "text": "Check Data With Metacore\nWe use metacore to perform a number of checks on the data. We will drop variables not in the specs and make sure all the variables from the specs are included.\n\n# Final Steps, Select final variables and Add labels\n# This process will be based on your metadata, no example given for this reason\n# ...\ndir <- \".\"\n\n# Apply metadata and perform associated checks ----\n# uses {metatools}\n\nadppk <- adppk_prefinal %>%\n  drop_unspec_vars(metacore) %>% # Drop unspecified variables from specs\n  check_variables(metacore) %>% # Check all variables specified are present and no more\n  check_ct_data(metacore) %>% # Checks all variables with CT only contain values within the CT\n  order_cols(metacore) %>% # Orders the columns according to the spec\n  sort_by_key(metacore) # Sorts the rows by the sort keys"
  },
  {
    "objectID": "adam/adppk.html#apply-labels-and-formats-with-xportr",
    "href": "adam/adppk.html#apply-labels-and-formats-with-xportr",
    "title": "ADPPK",
    "section": "Apply Labels and Formats with xportr",
    "text": "Apply Labels and Formats with xportr\nUsing {xportr} we check variable type, assign variable lenght, add variable labels, add variable formats, and save a transport file.\n\nadppk_xpt <- adppk %>%\n  xportr_type(metacore) %>% # Coerce variable type to match spec\n  xportr_length(metacore) %>% # Assigns SAS length from a variable level metadata\n  xportr_label(metacore) %>% # Assigns variable label from metacore specifications\n  xportr_format(metacore) %>% # Assigns variable format from metacore specifications\n  xportr_df_label(metacore) %>% # Assigns dataset label from metacore specifications\n  xportr_write(file.path(dir, \"adppk.xpt\")) # Write xpt v5 transport file"
  },
  {
    "objectID": "adam/adppk.html#save-final-output",
    "href": "adam/adppk.html#save-final-output",
    "title": "ADPPK",
    "section": "Save Final Output",
    "text": "Save Final Output\nFinally we save the final output. We will also create a CSV file for the modeler.\n\n# ---- Save output ----\nsaveRDS(adppk, file = file.path(dir, \"adppk.rds\"), compress = \"bzip2\")\n\n# Write CSV\nwrite_csv(adppk_xpt, \"adppk.csv\")"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "pharmaverse examples",
    "section": "",
    "text": "This book contains end-to-end examples of using pharmaverse packages together to achieve common clinical reporting analyses. The examples use consistent source SDTMs to create ADaMs (such as ADSL, ADPC, ADPPK) and using these as input to produce some familiar Tables/Listings/Graphs and associated interactive displays (via Shiny).\nOther examples may be included here, e.g. Therapeutic Area specifics (such as Oncology or Vaccines).\nNote that this examples book should only be used to show how collections of packages can be used in conjunction - more thorough examples of individual package usages would always be covered in the package site vignettes and no need to repeat here.\nIf you’d like to try out any of these examples in a live R session (via Posit Cloud) or if you are interesting in contributing an article to this book, then see more in our GitHub repo README."
  }
]