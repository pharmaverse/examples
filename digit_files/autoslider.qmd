---
title: "Pharmaverse Example"
date: "`r Sys.Date()`"
output:
    rmarkdown::html_document:
        theme: "spacelab"
        highlight: "kate"
        toc: true
        toc_float: true
author: 
  - Joe Zhu [`shajoezhu`]
  - Yolanda Zhou ([`yolandazzz13`])

vignette: >
  %\VignetteIndexEntry{Pharmaverse Example: Introduction to `autoslider.core`}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
editor_options:
    markdown:
        wrap: 72
---

```{r, include = FALSE}
suggested_dependent_pkgs <- c("filters")
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = all(vapply(
    suggested_dependent_pkgs,
    requireNamespace,
    logical(1),
    quietly = TRUE
  ))
)
```
```{r, echo=FALSE}
knitr::opts_chunk$set(comment = "#")
```


In this vignette, we show the general `autoslider.core` workflow, how you can create functions from our templates and produce study-specific outputs, and how you can integrate them into the `autoslider.core` framework to automate slide generation.

```{r, echo = FALSE, include = FALSE}
library(autoslider.core)
library(dplyr)
```


```{r, eval = TRUE, include = FALSE}
# hidden setup
# Install and load the necessary packages
library(yaml)
library(assertthat)
library(tern)

# Create the YAML content
yaml_content <- '
ITT:
  title: Intent to Treat Population
  condition: ITTFL == "Y"
  target: adsl
  type: slref
SAS:
  title: Secondary Analysis Set
  condition: SASFL == "Y"
  target: adsl
  type: slref
SE:
  title: Safety Evaluable Population
  condition: SAFFL== "Y"
  target: adsl
  type: slref
SER:
  title: Serious Adverse Events
  condition: AESER == "Y"
  target: adae
  type: anl
LBCRP:
  title: CRP Values
  condition: PARAMCD == "CRP"
  target: adlb
  type: slref
LBNOBAS:
  title: Only Visits After Baseline
  condition: ABLFL != "Y" & !(AVISIT %in% c("SCREENING", "BASELINE"))
  target: adlb
  type: slref
'

# Create a temporary YAML file
filters <- tempfile(fileext = ".yaml")

# Write the YAML content to the temporary file
write(yaml_content, file = filters)

# Create the specs entry
specs_entry <- '
- program: t_ds_slide
  titles: Patient Disposition ({filter_titles("adsl")})
  footnotes: "t_ds footnotes"
  paper: L6
  suffix: ITT
- program: t_dm_slide
  titles: Patient Demographics and Baseline Characteristics
  footnotes: "t_dm_slide footnote"
  paper: L6
  suffix: ITT
  args:
    arm: "TRT01A"
    vars: ["SEX", "AGE", "RACE"]
'

# Create a temporary specs entry file
spec_file <- tempfile(fileext = ".yaml")

# Write the specs entry to the temporary file
write(specs_entry, file = spec_file)

# This chunk runs first and prepares the environment for the whole document

# 1. Load ALL necessary packages
library(rtables)      # For append_topleft()
library(dplyr)       # For %>% and other functions
library(assertthat)   # For assert_that() you had issues with before
# ... add any other packages your report uses

# 3. Load any data files needed
# data <- read.csv(here("data", "my_data.csv"))

# Clean up the temporary files
# file.remove(filters)
# file.remove(spec_file)
```

# Background
In dose escalation trials, the frequent and rapid reporting of safety data for the Safety Review and Evaluation Plan (SREP) is critical for timely decision-making. The traditional workflow involves statisticians manually transcribing these numbers into presentation slides, which makes the process inefficient and error-prone.

autoslideR solves this problem by automating the creation of slides. As an extension of the EnableRF framework, autoslideR uses tern/rtables to create robust table objects from analysis data. It then utilizes the flextable package to format these tables and renders them directly into a standardized PowerPoint (.pptx) file ready for presentation.

To contribute to a collaborative environment, we have open-sourced the backbones of autoslideR on GitHub at https://github.com/insightsengineering/autoslider.core. This package offers a practical solution to streamlining safety reporting and enhancing the efficiency of clinical trials.


# Prerequisites



First and foremost, you need to have the `autoslider.core` package installed, and you need to have data available.
In this example I am using example data stored in the `autoslider.core` package. The data needs to be stored in a named list where the names should correspond to ADaM data sets.

## File structure


The folder structure could look something like: 

```
├── programs
│   ├── run_script.R
│   ├── R   
|   |   ├── template_functions.R
|   |   ├── output_functions.R
├── outputs
├── spec.yml
├── filters.yml
```

The `autoslideR` workflow would be implemented in the `run_script.R` file.
This workflow does not require the files in `programs/R/`. 
However, if custom `output_functions.R` are implemented, `programs/R/` would be the place to put them.

The `autoslideR` workflow has four main aspects: 

## The specifications `specs.yml` 

This file contains the specifications of all outputs you would like to create.

For each output we define specific information, namely the program name, the footnotes & titles, the paper (this indicates the orientation, P for portrait and L for landscape, the number indicates the font size), the suffix and `args`.

It could look something like that:

```
- program: t_ds_slide
  titles: Patient Disposition ({filter_titles("adsl")})
  footnotes: 't_ds footnotes'
  paper: L6
  suffix: ITT
- program: t_dm_slide
  titles: Patient Demographics and Baseline Characteristics
  footnotes: 't_dm_slide footnote'
  paper: L6
  suffix: ITT
  args:
    arm: "TRT01A"
    vars: ["SEX", "AGE", "RACE"]

```

The program name refers to a function that produces an output. 
This could be one of the template functions provided in `autoslider.core` or a custom function. See vignette `adding_templates` for a detailed guide on using templates in the `autoslider.core` framework.

Titles and footnotes are added once the outputs are created.
We refer to that as decorating the outputs.

The suffix specifies the name of the filters that are applied to the data, before the data is funneled into the function (program).
The filters themselves are specified in the `filters.yml` file.

## The filters `filters.yml`

In `filters.yml` we specify the names of the filters used across the outputs. 
Each filter has a name (e.g. `FAS`), a title (`Full Analysis Set`), and then the filtering condition on a target dataset. 
The filter title may be appended to the output title. For the `t_ds_slides` slide above all filter titles that target the adsl dataset would be included in the brackets. 
We would thus expect the title to read: "Patient Disposition (Full Analysis Set)"

[what is the type?]

As you can see, we don't just have population filters, but also filters on serious adverse events. 
We can thus produce SAE tables by just supplying the serious adverse events to the AE table function. 
This concept generalizes also to `PARAMCD` values.


```
ITT:
  title: Intent to Treat Population
  condition: ITTFL =='Y'
  target: adsl
  type: slref
SAS:
  title: Secondary Analysis Set
  condition: SASFL == 'Y'
  target: adsl
  type: slref
SE:
  title: Safety Evaluable Population
  condition: SAFFL=='Y'
  target: adsl
  type: slref
SER:
  title: Serious Adverse Events
  condition: AESER == 'Y'
  target: adae
  type: anl

```

# AutoslideR typical workflow example

A typical workflow could look something like this: 

```{r, eval = FALSE}
# define path to the yml files
#setwd("path/to/autoslider.core")
spec_file <- "spec.yml"
filters <- "filters.yml"
```

```{r, include = FALSE}
#setwd("~/autoslider.core")

```

```{r}
library("dplyr")
# load all filters
filters::load_filters(filters, overwrite = TRUE)
# read data
data <- list(
  "adsl" = eg_adsl %>%
    mutate(
      FASFL = SAFFL, # add FASFL for illustrative purpose for t_pop_slide
      # DISTRTFL is needed for t_ds_slide but is missing in example data
      DISTRTFL = sample(c("Y", "N"), size = length(TRT01A), replace = TRUE, prob = c(.1, .9))
    ) %>%
    preprocess_t_ds(), # this preproccessing is required by one of the autoslider.core functions
  "adae" = eg_adae,
  "adtte" = eg_adtte,
  "adrs" = eg_adrs,
  "adlb" = eg_adlb
)

# create outputs based on the specs and the functions
outputs <- spec_file %>%
  read_spec() %>%
  # we can also filter for specific programs:
  filter_spec(., program %in% c("t_ds_slide", "t_dm_slide")) %>%
  # these filtered specs are now piped into the generate_outputs function.
  # this function also requires the data
  generate_outputs(datasets = data) %>%
  # now we decorate based on the specs, i.e. add footnotes and titles
  decorate_outputs(
    version_label = NULL
  )
```


We can have a look at one of the outputs stored in the outputs file:
```{r}
outputs$t_dm_slide_ITT
```


```{r}

outputs %>%
  generate_slides(
    outfile = "presentation.pptx",
    template = file.path(system.file(package = "autoslider.core"), "/theme/basic.pptx"),
    table_format = autoslider_format
  )
```


# Extension: customize your autoslideR experience

### Create custom function from templates

Unless your requirements are really specific, the most efficient way to write a study function is to base it off of a template function from the [TLG catalogue](https://insightsengineering.github.io/tlg-catalog/stable/). 

The function you would want to create should take as input a list of datasets and potentially additional arguments. 
Within the function, you should not worry about filtering the data, as this should be taken care of with the `filters.yml` file and the general workflow. 

To see a complete list of template functions that the `autoslider.core` provides, we can call the function below to retrieve their names.
```{r, include = TRUE, eval = FALSE}
list_all_templates()
```
This will return a character vector of supported templates, you can extract their basenames (e.g., `t_dm_slide`, `g_ae_slide`, etc.), each corresponding to a table type stored in the `R/` folder of the package.

Then, use the `use_template()` function to generate a template script that you can customize. For example:

```{r_function_call, include = TRUE, eval = TRUE}
use_template(template = "t_dd_slide", function_name = "tryout")

```
This will create a function called `tryout` that resides in the file with the `t_dd_slide` (Death table) template at `tryout.R`. Please feel free to make your own modification and customization based on the goal of your study. 

For detailed template usage instructions, please refer to vignette `tlg_templates`.

This function, like other template functions in `autoslider.core`, will convert data into TLG formats, given the help of configurations in `spec.yml` and `filters.yml`. Now let's verify this.


### Integrate it into the general workflow

You have to keep in mind that the function you created must be in the global environment when calling the `create_outputs` function. 
This is the case for all `autoslider.core` functions, as you attach the `autoslider.core` package (with your `library(autoslider.core)` call), so all (exported) function of the `autoslider.core` package are available.

If you store your custom function in a separate script, you would need to source that script at some point before calling the function.

Now you just have to make sure the two `.yml` files are correctly specified. Specifically, you have to append a new entry into `spec.yml` to incorporate the new program you just created. For example:

```{r, eval = FALSE}
- program: tryout
  titles: Deaths and Causes of Death
  footnotes: ''
  paper: L6
  suffix: SE
  args:
    arm: "TRT01A"
```

You also have to make sure that filters.yml contains the filter that matches your purposes specified in `suffix`. In this case:
```{r, eval = FALSE}
SE:
  title: Safety Evaluable Population
  condition: SAFFL=='Y'
  target: adsl
  type: slref
```

Then you can load the filters and generate the outputs.

```{r, include = FALSE}
library(yaml)

# Create the YAML content
yaml_content <- '
SE:
  title: Safety Evaluable Population
  condition: SAFFL=="Y"
  target: adsl
  type: slref
'

# Create a temporary YAML file
filters <- tempfile(fileext = ".yaml")

# Write the YAML content to the temporary file
write(yaml_content, file = filters)

# Create the specs entry
specs_entry <- '
- program: tryout
  titles: Deaths and Causes of Death
  footnotes: ""
  paper: L6
  suffix: SE
  args:
    arm: "TRT01A"
'

# Create a temporary specs entry file
spec_file <- tempfile(fileext = ".yaml")

# Write the specs entry to the temporary file
write(specs_entry, file = spec_file)

```

```{r, eval = TRUE}
filters::load_filters(filters, overwrite = TRUE)

outputs <- spec_file %>%
  read_spec() %>%
  filter_spec(., program == "tryout") %>%
  generate_outputs(datasets = data) %>%
  decorate_outputs()

# Naming convention is program name + suffix
outputs$tryout_SE

```

Once this works, we can generate the slides, feel free to pass in your desired pptx template. 

```{r, eval = FALSE}
filepath <- "outputs/tryout.pptx"
generate_slides(outputs, outfile = filepath, template = "path/to/your/custom_template.pptx")
```

Below is an example presentation output with placeholder slides (explained in the `generate_placeholder_slides` vignette ) and SREP standard presentation slides:


![With placeholder example 1](pharmaverse_output_1.png){fig-align="center"}
![With placeholder example 2](pharmaverse_output_2.png){fig-align="center"}

![Example Reviewer's Guide Table](srep_screenshot.png){fig-align="center"}
